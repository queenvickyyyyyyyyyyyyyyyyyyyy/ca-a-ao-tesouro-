import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Random;
import java.util.Scanner;
import java.util.Set;

// Classe que orquestra a l√≥gica do jogo
public class Jogo {
    private ElementoTabuleiro[][] tabuleiro;
    private Jogador jogador;
    private int tesourosRestantes;
    private int movimentosRestantes;
    // Usa um Set para armazenar as posi√ß√µes j√° visitadas, o que √© mais eficiente
    // para buscas do que verificar uma matriz separada.
    private Set<Posicao> posicoesVisitadas;

    public Jogo() {
        tabuleiro = new ElementoTabuleiro[6][6];
        jogador = new Jogador();
        tesourosRestantes = 3;
        movimentosRestantes = 10;
        posicoesVisitadas = new HashSet<>();
        inicializarTabuleiro();
    }

    private void inicializarTabuleiro() {
        Random rand = new Random();
        
        // Inicializa tudo como vazio
        for (int i = 0; i < 6; i++) {
            for (int j = 0; j < 6; j++) {
                tabuleiro[i][j] = new Vazio();
            }
        }
        
        // Coloca tesouros
        for (int i = 0; i < 3; i++) {
            int x, y;
            do {
                x = rand.nextInt(6);
                y = rand.nextInt(6);
            } while (!(tabuleiro[x][y] instanceof Vazio) || (x == 0 && y == 0));
            tabuleiro[x][y] = new Tesouro();
        }
        
        // Coloca armadilhas
        for (int i = 0; i < 3; i++) {
            int x, y;
            do {
                x = rand.nextInt(6);
                y = rand.nextInt(6);
            } while (!(tabuleiro[x][y] instanceof Vazio) || (x == 0 && y == 0));
            tabuleiro[x][y] = new Armadilha();
        }
    }

    public void jogar() {
        Scanner scanner = new Scanner(System.in);
        
        // Adiciona a posi√ß√£o inicial do jogador como visitada
        posicoesVisitadas.add(new Posicao(jogador.getX(), jogador.getY()));

        while (movimentosRestantes > 0 && tesourosRestantes > 0) {
            exibirTabuleiro();
            System.out.println("Movimentos restantes: " + movimentosRestantes);
            System.out.println("Tesouros restantes: " + tesourosRestantes);
            System.out.println("Pontos: " + jogador.getPontos());
            System.out.print("Movimento (W/A/S/D): ");
            
            char direcao = scanner.next().toUpperCase().charAt(0);
            
            // Salva a posi√ß√£o anterior antes de mover
            int xAnterior = jogador.getX();
            int yAnterior = jogador.getY();
            
            jogador.mover(direcao);
            
            int x = jogador.getX();
            int y = jogador.getY();
            
            // Cria um objeto Posicao para a nova coordenada
            Posicao novaPosicao = new Posicao(x, y);

            // Usa a cole√ß√£o de posi√ß√µes visitadas para verificar se a posi√ß√£o √© nova
            if (!posicoesVisitadas.contains(novaPosicao)) {
                // **Polimorfismo:** A intera√ß√£o agora √© mais clara e o tipo espec√≠fico do elemento
                // √© gerenciado de forma polim√≥rfica.
                ElementoTabuleiro elemento = tabuleiro[x][y];
                
                // Usa um Map para gerenciar as intera√ß√µes de forma din√¢mica
                Map<Class<? extends ElementoTabuleiro>, Runnable> interacoes = new HashMap<>();
                
                // Adiciona a l√≥gica de intera√ß√£o para cada tipo de elemento
                // A chave do Map √© a classe do objeto (ex: Tesouro.class)
                // O valor √© um objeto Runnable que cont√©m a a√ß√£o a ser executada
                interacoes.put(Tesouro.class, () -> {
                    jogador.addPontos(elemento.interagir());
                    tesourosRestantes--;
                });
                interacoes.put(Armadilha.class, () -> {
                    jogador.addPontos(elemento.interagir());
                });
                interacoes.put(Vazio.class, () -> {
                    jogador.addPontos(elemento.interagir());
                });

                // Executa a a√ß√£o correspondente ao tipo de elemento na posi√ß√£o atual
                Runnable acao = interacoes.get(elemento.getClass());
                if (acao != null) {
                    acao.run();
                }

                // Adiciona a nova posi√ß√£o ao conjunto de posi√ß√µes visitadas
                posicoesVisitadas.add(novaPosicao);
            }
            
            movimentosRestantes--;
        }
        
        exibirResultadoFinal();
        scanner.close();
    }

    private void exibirTabuleiro() {
        System.out.println("\nTabuleiro:");
        for (int i = 0; i < 6; i++) {
            for (int j = 0; j < 6; j++) {
                Posicao posicaoAtual = new Posicao(i, j);
                if (posicoesVisitadas.contains(posicaoAtual)) {
                    // **Polimorfismo:** Chama o m√©todo simbolo() do tipo de objeto real
                    System.out.print(tabuleiro[i][j].simbolo() + " ");
                } else if (i == jogador.getX() && j == jogador.getY()) {
                    System.out.print("üë§ ");
                } else {
                    System.out.print("‚ùì ");
                }
            }
            System.out.println();
        }
    }

    private void exibirResultadoFinal() {
        System.out.println("\n=== FIM DE JOGO ===");
        System.out.println("Pontua√ß√£o final: " + jogador.getPontos());
        System.out.println("Tesouros encontrados: " + (3 - tesourosRestantes));
        exibirTabuleiro();
    }
}

// Classe auxiliar para representar uma posi√ß√£o (coordenada x, y)
// √â necess√°rio sobrescrever equals() e hashCode() para que o Set funcione corretamente
class Posicao {
    private final int x;
    private final int y;

    public Posicao(int x, int y) {
        this.x = x;
        this.y = y;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Posicao posicao = (Posicao) o;
        return x == posicao.x && y == posicao.y;
    }

    @Override
    public int hashCode() {
        return 31 * x + y;
    }
}
